#labels Phase-Implementation
Documentación de los módulos gfp y gfnp, explicando sus clases y métodos.

= Introducción =

Ambos módulos, gfp y gfnp son en su estructura interna exactamente iguales. gfp es el que contiene a los generadores de funciones periódicas y gfnp es el que contiene a los generadores de funciones no periódicas.
Estos generados son en esencia generadores en tiempo real. Es decir que generan la función no en tiempos digitales sino que lo hacen en linea.
Esta característica hace que se pueda inyectar la señal directamente a un conversor digital analógico o a una placa de sonido. También podría inyectarse por software a otro programa que la reproduzca.
Todos los generadores son clases que heredan gran parte de su funcionalidad de los Thread de Python, por lo que quedan corriendo "por detrás" de nuestra aplicación.

= gfp =
Es el modulo encargado de contener las clases generadoras de funciones periódicas.
Las funciones que alberga actualmente son:
  * Seno
  * Diente de sierra
  * Onda triangular
  * Onda cuadrada
Todas las clases generadoras tienen los metodos start(), stop(), pause() y el atributo dat que es donde se almacena el estado actual de la función.
El método start() comienza la generación de la función instanciada, stop() lo detiene y finaliza. Por último pause() funciona junto con el argumento True o False. De esta manera se pausa o deja proseguir la generación de la función. Mientras la generación está pausada, el valor de dat no cambia en absoluto, conservando el valor último que había tomado.

  ==Seno==
  Esta función se instancia mediante gfp.SinSignal(dc, ampl, freq, phase, rate)
  Siendo:
  * dc: la componente de continua sobre la que se monta la señal
  * ampl: la amplitud máxima que alcanzará la señal
  * freq: la frecuencia de la señal
  * phase: la fase de la señal
  * rate: la frecuencia de sampleo con que se genera la señal. Para que no haya alias esta frecuencia debe ser al menos dos veces mayor a la frecuencia de la señal

    ===Ejemplo de uso===
    >>> import gfp as sig

    >>> sin = sig.SinSignal(0,1,10,0,100)

    >>> sin.start()

    >>> sin.dat

    0.58778525229245859

    >>> sin.dat

    0.95105651629516452

    >>> sin.dat

    -0.58778525229245693

    >>> sin.stop()

    En este caso se mostró el valor de la señal (sin.dat) en un instante arbitrario. Para poder reproducir la señal habría que hacer una adquisición de sin.dat por lo menos a una frecuencia igual a rate.


  ==Diente de sierra==
  Esta función se instancia mediante gfp.SawtoothSignal(dc, ampl, freq, phase, rate, width=0.5)
  Siendo:
  * dc: la componente de continua sobre la que se monta la señal
  * ampl: la amplitud máxima que alcanzará la señal
  * freq: la frecuencia de la señal
  * phase: la fase de la señal
  * rate: la frecuencia de sampleo con que se genera la señal. Para que no haya alias esta frecuencia debe ser al menos dos veces mayor a la frecuencia de la señal
  * width: es la fracción de periodo en el cual se produce el máximo del diente de sierra. Este valor va de 0 a 1.

    ===Ejemplo de uso===
    >>> import gfp as sig 

    >>> dds = sig.SawtoothSignal(0,1,10,0,100,0.7)

    >>> dds.start()

    >>> dds.dat

    0.37626295104382734

    >>> dds.dat

    0.37626295104382734

    >>> dds.dat

    0.4808799060989486

    >>> dds.dat

    0.4808799060989486

    >>> dds.dat

    -0.66197723675816178

    >>> dds.stop()

    En este caso se mostró el valor de la señal (dds.dat) en un instante arbitrario. Para poder reproducir la señal habría que hacer una adquisición de dds.dat por lo menos a una frecuencia igual a rate.
    
  ==Onda triangular==
  Esta función se instancia mediante gfp.TriangleSignal(dc, ampl, freq, phase, rate)
  Siendo:
  * dc: la componente de continua sobre la que se monta la señal
  * ampl: la amplitud máxima que alcanzará la señal
  * freq: la frecuencia de la señal
  * phase: la fase de la señal
  * rate: la frecuencia de sampleo con que se genera la señal. Para que no haya alias esta frecuencia debe ser al menos dos veces mayor a la frecuencia de la señal
  
  En esencia es una onda tipo diente de sierra con el parámetro width fijo en 0.5

    ===Ejemplo de uso===
    >>> import gfp as sig

    >>> tri = sig.TriangleSignal(0,1,10,0,100)

    >>> tri.start()

    >>> tri.dat

    -0.60000000000002274
    
    >>> tri.dat

    -0.59999999999996634

    >>> tri.dat
    
    1.0
    
    >>> tri.stop()

    En este caso se mostró el valor de la señal (tri.dat) en un instante arbitrario. Para poder reproducir la señal habría que hacer una adquisición de tri.dat por lo menos a una frecuencia igual a rate.


  ==Onda cuadrada==
  Esta función se instancia mediante gfp.SquareSignal(dc, ampl, freq, phase, rate, duty=0.5)
  Siendo:
  * dc: la componente de continua sobre la que se monta la señal
  * ampl: la amplitud máxima que alcanzará la señal
  * freq: la frecuencia de la señal
  * phase: la fase de la señal
  * rate: la frecuencia de sampleo con que se genera la señal. Para que no haya alias esta frecuencia debe ser al menos dos veces mayor a la frecuencia de la señal
  * duty: el fracción de periodo en que la señal se encuentra en estado alto (ciclo de trabajo). duty debe estar entre 0 y 1
  
  En esencia es una onda tipo diente de sierra con el parámetro width fijo en 0.5

    ===Ejemplo de uso===
    >>> import gfp as sig

    >>> quad = sig.SquareSignal(0,1,10,0,100,0.5)

    >>> quad.start()

    >>> quad.dat
    
    0
    
    >>> quad.dat
    
    0
    
    >>> quad.dat
    
        1
        
    >>> quad.dat
    
        1
    
    >>> quad.stop()
    
En este caso se mostró el valor de la señal (quad.dat) en un instante arbitrario. Para poder reproducir la señal habría que hacer una adquisición de quad.dat por lo menos a una frecuencia igual a rate.



= gfnp =
Es el modulo encargado de contener las clases generadoras de funciones no periódicas.
Las funciones que alberga actualmente son:
  * Señal aleatoria
  * Pulso
  * Escalón
  * Rampa
Todas las clases generadoras tienen los metodos start(), stop(), pause() y el atributo dat que es donde se almacena el estado actual de la función.
El método start() comienza la generación de la función instanciada, stop() lo detiene y finaliza. Por último pause() funciona junto con el argumento True o False. De esta manera se pausa o deja proseguir la generación de la función. Mientras la generación está pausada, el valor de dat no cambia en absoluto, conservando el valor último que había tomado.

  ==Señal aleatoria==
  Esta función se instancia mediante gfnp.RandomSignal(dc, hi, low, rate)
  Siendo:
  * dc: la componente de continua sobre la que se monta la señal
  * hi: el máximo valor que puede tomar la señal
  * low: el mínimo valor que puede tomar la señal
  * rate: la frecuencia de sampleo con que se genera la señal.

    ===Ejemplo de uso===
    >>> import gfnp as sig

    >>> ran = sig.RandomSignal(0,1,-1,100)

    >>> ran.start()

    >>> ran.dat

    0.98625539020219599

    >>> ran.dat

    0.34830366602194052

    >>> ran.dat

    -0.66773361171216128
 
    >>> ran.stop()


    En este caso se mostró el valor de la señal (ran.dat) en un instante arbitrario. Para poder reproducir la señal habría que hacer una adquisición de ran.dat por lo menos a una frecuencia igual a rate.

  ==Pulso==
  Esta función se instancia mediante gfnp.PulseSignal(dc, ampl, t, rate)
  Siendo:
  * dc: la componente de continua sobre la que se monta la señal
  * ampl: la amplitud máxima que alcanzará la señal
  * t: el tiempo a partir de start(), en segundos, al que se produce el pulso
  * rate: la frecuencia de sampleo con que se genera la señal.

Una aclaración importante sobre esta función es que, si bien tiene propiedades temporales similares, no es la función impulso. La punción pulso que aquí se genera tiene una amplitud finita, mientras que la función impulso tiene amplitud infinita y energía unitaria.
Sin embargo, para muchos usos puede reemplazarse la función impulso con la función pulso.

    ===Ejemplo de uso===
    >>> import gfnp as sig

    >>> pul = sig.PulseSignal(0,1,0.5,100)

    >>> pul.start()

    >>> pul.dat

    0

    >>> pul.dat

    0

    >>> pul.dat

    0
 
    >>> pul.stop()


    En este caso se mostró el valor de la señal (pul.dat) en un instante arbitrario. Para poder reproducir la señal habría que hacer una adquisición de pul.dat por lo menos a una frecuencia igual a rate.
También puede observarse que el pulso no fue detectado ya que ninguna de las adquisiciones coincidió con el acontecimiento del pulso.


  ==Escalón==
  Esta función se instancia mediante gfnp.StepSignal(dc, ampl, t, rate)
  Siendo:
  * dc: la componente de continua sobre la que se monta la señal
  * ampl: la amplitud máxima que alcanzará la señal
  * t: el tiempo a partir de start(), en segundos, al que se produce el escalón
  * rate: la frecuencia de sampleo con que se genera la señal.

Si se mantiene la amplitud ampl, de esta función en 1 entonces será el escalón unitario.

    ===Ejemplo de uso===
    >>> import gfnp as sig

    >>> u = sig.StepSignal(0,1.3,1,100)

    >>> u.start()

    >>> u.dat

    0

    >>> u.dat

    0

    >>> u.dat

    1.3
   
    >>> u.dat

    1.3
 
 
    >>> u.stop()


    En este caso se mostró el valor de la señal (u.dat) en un instante arbitrario. Para poder reproducir la señal habría que hacer una adquisición de u.dat por lo menos a una frecuencia igual a rate.
Puede observarse que la función vale 0 hasta alcanzado cierto tiempo (t) en donde comienza a valer 1.3 para todo tiempo futuro.

  ==Rampa==
  Esta función se instancia mediante gfnp.RampSignal(dc, pend, t, rate)
  Siendo:
  * dc: la componente de continua sobre la que se monta la señal
  * pend: la pendiente con la que evolucionará la señal
  * t: el tiempo a partir de start(), en segundos, en el que comienza la rampa
  * rate: la frecuencia de sampleo con que se genera la señal.

Podría considerarse que esta función es una función diente de sierra con un periodo infinito. Claro que podría realizarse mediante la función gfp.SawTooth con una frecuencia muy pequeña. Sin embargo se prefirió escribir una clase exclusiva para la rampa.
Debe tenerse en cuenta que esta función crece indefinidamente por lo que si se aplica a un dispositivo de hardware como la placa de sonido, seguramente se saturará en algún momento.

    ===Ejemplo de uso===
    >>> import gfnp as sig

    >>> ramp = sig.RampSignal(0,0.25,1,100)

    >>> ramp.start()

    >>> ramp.dat

    0

    >>> ramp.dat

    0.58499999999999996

    >>> ramp.dat

    0.78499999999999992

    >>> ramp.dat

    1.0024999999999999

    >>> ramp.stop()


    En este caso se mostró el valor de la señal (ramp.dat) en un instante arbitrario. Para poder reproducir la señal habría que hacer una adquisición de ramp.dat por lo menos a una frecuencia igual a rate.